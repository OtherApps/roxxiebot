
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>RoxxieBot â€“ Stars System (Christmas Edition)</title>
<script>
<!-- 
	const queryString = window.location.search;
	const urlParams = new URLSearchParams(queryString); 
	var offline=urlParams.get("offline") ?? true; 
	var fixurl,serverURL
	var tsoh =  urlParams.get("streamer") ?? "RoxxieToxxic";
	
if(offline!=false){
console.log("offline");

fixurl = "http://192.168.1.172:8080/raw?url=";
serverURL= "http://192.168.1.172:8080/"; 

}
else{
console.log("online");
serverURL= "https://roxxiebot.ngrok.app/"; 
fixurl ="https://roxxiebot.ngrok.app/raw?url="

}

//-->
</script>
<script src="functions.js"></script>

    <link rel="stylesheet" href="main.css">
<style>

</style>
</head>
<body>
<div class="snow"></div>

<h1>
  <span class="emoji">ğŸ„</span>
  RoxxieBot â€“ Stars System
  <span class="emoji">â­</span>
  <span class="emoji">ğŸ</span>
</h1>
<p class="small-note">
  <strong>Christmas Edition:</strong> same Stars logic, cozy festive skin. Works for Twitch / TikTok / YouNow, leaderboard shows combined Stars.
</p>

<div class="card" style="max-width:1040px;">
  <div class="card-header-row">
    <h2 style="margin:0;">Leaderboard (Top 10 â€“ Combined Stars)</h2>
  
  </div>
  <p class="small-note">
    If someone rockets from 3rd to 1st place, their row will gracefully slide up like a festive arrivals board, pushing others down.
  </p>
  <table>
    <thead>
      <tr>
        <th>#</th>
        <th>Username</th>
        <th>Stars</th>
		<th>Stickers</th>
        
      </tr>
    </thead>
    <tbody id="leaderboard-body"></tbody>
  </table>
</div>
<script>
<!--

function aggregated() {
  const map = {};
 
  viewers.forEach(v => {
 
    const key = v.username.toLowerCase();
    if (!map[key]) map[key] = { key, username: v.username, stars: 0 };
    map[key].stars += v.stars;
  });
 //console.log(Object.values(map));
  
  
  
  return Object.values(map);
}


function loadViewers(data) {
console.log("Loading viewers");

	const raw=data;
	if (!raw) { viewers = []; return; }
		try { viewers = JSON.parse(raw) || []; } catch(e) { console.log(e);viewers = []; }
		
		viewers.forEach(v => { 
		if (typeof v.stars === "undefined")
		{v.stars = 0}else{
		v.stars=parseInt(v.stars);
		
		};
		if(isNaN(v.stickers)){
		v.stickers=0}
		});
	
	//adjustNames(viewers);
	renderLeaderboard()
  
}

function renderLeaderboard() {
//loadJson(); 
 const tbody = document.getElementById("leaderboard-body");
  const oldRows = Array.from(tbody.querySelectorAll("tr[data-id]"));
  const oldPos = {};
  oldRows.forEach(r => oldPos[r.dataset.id] = r.getBoundingClientRect().top);
  const sorted = aggregated().sort((a,b)=>b.stars-a.stars);
  const rowMap = {};
  
  oldRows.forEach(r=>rowMap[r.dataset.id]=r);
  tbody.innerHTML = "";
  //console.log(viewers);
  
  sorted.forEach((u, i)=>{
    let row = rowMap[u.key];
    if (!row) { row = document.createElement("tr"); row.dataset.id = u.key; }
    else { row.innerHTML = ""; }
	
	const ix=viewers.findIndex(p => p.username === u.username);
	
    row.innerHTML = `
      <td>${i+1}</td>
      <td>${u.username}</td>
      <td>${u.stars}</td>
	  <td>${viewers[ix].stickers}</td>
    `;
    tbody.appendChild(row);
  });
  const newRows = Array.from(tbody.querySelectorAll("tr[data-id]"));
  newRows.forEach(row=>{
    const id=row.dataset.id;
    if (oldPos[id]!=null){
      const newY=row.getBoundingClientRect().top;
      const delta=oldPos[id]-newY;
      if (Math.abs(delta)>2){
        row.style.transform=`translateY(${delta}px)`;
        row.classList.add("moved");
        requestAnimationFrame(()=> row.style.transform="" );
      }
    }
  });
}
//-->
</script>
<script>
let viewers = [];
let doubleStars = false;
let currentViewer = null;

loadJson();
//renderLeaderboard();
//updateCurrentViewerLabel();
</script>

</body>
</html>
